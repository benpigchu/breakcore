# 第四章：内存管理与虚拟内存

## 内核堆

我们使用 buddy_system_allocator 库进行内存管理。这个库使用了 buddy_system 算法来分配内存。把它提供的 LockedHeap 作为堆内存分配器 `#[global_allocator]` 使用，并开一个大数组作为堆空间为进去即可。同时我们也定义 `#[alloc_error_handler]` ，使得内存不够时打印信息并停机。

有了内核堆，我们就可以使用 alloc 包的内容了，这样就可以自由地使用 Box、Arc、Vec 等进行动态内存分配了。

## Bonus：更详细的报错信息

有了堆内存，我们可以开始解析二进制中含有的调试相关信息了，为此我们首先需要在我们的二进制中放置内核调试信息。第一步是提取调试信息，这一部分只需要使用`objcopy` 加上 `--only-keep-debug`就好。第二步是把调试信息加载到内存中，这里我们使用 qemu 的 loader 设备来完成，注意为了避免 qemu 解析 ELF 格式我们需要指定 `force-raw=on`。为了方便，我们把调试信息加载到 `0x80800000` 处。第三步是在内核中读取调试信息，这里我们相应使用 `object` 库解析 ELF 格式，并将相应的段喂给 `addr2line` 库里带的 `gimli` 库。最后，我们在打印 backtrace 时，使用 ra 地址信息用 `addr2line` 库查询相关信息并打印即可。

这时，我们的内核报错打印 backtrace 时就能把函数名称和文件地址与行号列号也显示出来了，应该能对之后的调试产生很大的帮助。

另外，在 Release 模式下，需要在 `.cargo` 中指定输出调试信息，否则在 Release 模式下 Rust 不会生成调试信息，也就无法打印更详细的 backtrace 了

## 分配物理页

在正式分配物理页之前，我们首先建立一些辅助类型用来表示页号和地址，并编写一些工具函数方便对它们进行处理。

我们采取简单的栈式物理页管理策略进行物理页的管理。具体来说，就是保存还未进行分配的页的区间、以及一个回收的物理页表列表。分配时优先从回收的列表里取，再尝试从未分配的区间取。还回时直接加到回收的列表里即可。具体实现上我们利用回收的页的内部空间建立链表来管理回收的物理页，这样我们的物理页分配器便不依赖于内核堆。

最后为了让我们更好地管理页面的生命周期，我们用一个实现了 `Drop` 的 `Frame` 来表示物理页。这样当物理页的生命周期结束后，物理页会自动回收。

## 使用页表保护内存

首先我们需要能够操作页表结构。虽然我们使用的 `riscv` 包是有 Sv48 页表支持，但是我们要使用的是 Sv39 页表，所以我们得自己重新实现一遍。Sv39 页表的详细信息可以在 RISC-V 官方的文档找到，这里我们就不赘述了。在类型设计上我们用 `RawPageTable` 来封装页表操作，并用 `PageTable` 表示我们拥有所有权页表，用 `PageTableRef` 表示页表的不可变引用。`PageTable` 和 `PageTableRef` 分别实现了 `DerefMut` 和 `Deref` 两个 trait，这样就可以把它们当作 `RawPageTable` 的引用使用，同时保证通过 `PageTableRef` 只能获得页表的不可变引用，从而只能查阅页表，不能修改页表。`PageTable` 还实现了 `Drop` trait，这样在页表销毁的时候便可以自动返还占用的物理页。

接下来我们便可以启用页映射机制了。为此我们使用 `AddressSpace` 结构表示虚拟地址空间，其中含有一个页表结构。之所以要再包一层是因为将来逻辑上的映射可以和页表中的不一致。现在，我们把整个可用的物理地址空间以可读可写可执行的权限映射到编号相同的虚拟地址空间，并将页表信息填入 satp 寄存器，此时内核还能正常运行，说明我们的页表实现是正确的。然而，用户程序现在不能工作了，因为由于我们没有在页表内加入用户态权限，现在用户并不能访问内存了，所以在进入用户态时会发生页错误。当然，我们也不能直接让所有的页表页都加入用户态权限，因为在 S 态时是不能执行用户态的页内的代码的。

接下来，我们用 `VMObject` trait 来表示可以被映射到的物理内存，并用它们来在 `AddressSpace` 中建立映射关系。`VMObject` 现在只有两个方法，分别用来获取总页数和各个页的页号。这里我们先实现 `VMObjectPhysical`，它很简单，就是表示一段地址固定的连续物理页。接下来我们用 `VMMapping` 来记录。`AddressSpace` 到 `VMObject` 的映射，并在添加映射时修改页表即可。

接下来我们只需要整理一下物理内存空间，并分别建立 `VMObjectPhysical` ，以各自的 flag 进行映射即可。现在的内存布局如下所示（从 0x80000000开始，从低到高）：

- 内核二进制内的内容，这些内容的范围在连接器脚本中有标记，包括：
	- 代码段 .text，对应的 flags 为 RX
	- 只读数据段 .rodata，对应的 flags 为 R
	- 数据段 .data，对应的 flags 为 RW
	- 启动时的内核栈，对应的 flags 为 RW。注意在这一部分的前后分别利用连接器脚本留了一页的空白区域，用于在栈溢出时报页错误
	- .bss 与 .sbss 段除了内核栈以外的部分，对应的 flags 为 RW，但是目前用户栈还在这一段中，所以暂时还要加上 U
- 内核二进制的调试信息，对应的 flags 为 R
- 给应用程序预先分配的内存空间，对应的 flags 为 RWXU
- 由物理页分配器的内存空间，对应的 flags 为 RW

如此做好映射之后，还要为了在内核态时也能读写带有 U 标志位的页而设置 sstatus 中的 sum 标志位。此时便可以重新正常运行用户程序了。

## 使用页表隔离内核态和用户态的地址空间

现在，为了隔离不同用户程序的内存，我们有必要为各个用户程序分别使用不同的页表。

首先，我们要为各个用户程序建立不同的 `AddressSpace` ，并在其中映射用户程序的二进制内容和用户栈。接下来，我们便需要考虑在用户态与内核态切换时切换页表了。由于我们无法在从用户态进入内核态时同时切换页表，所以我们刚刚回到内核态时我们还得使用用户程序的页表，所以为了成功完成切换，我们需要把上下文切换相关的代码和内核栈也映射到用户地址空间中。为了方便之后更改应用程序二进制的地址空间，我们把上下文切换的代码和内核栈放到地址空间的最高处。

接下来我们可以开始修改用户态/内核态切换的过程了。首先由于上下文切换的代码的虚拟地址与物理地址不同了，我们需要让它的汇编与代码所在的地址无关，而这便需要我们在 `__alltraps` 中调用 `trap_handler` 时不直接使用 `call trap_handler` 这样的写法，因为汇编器在加载函数的地址时，是采取在当前 PC 上加上一个偏移的做法的，而这便会使虚拟地址发生变化时加载到错误的地址，从而无法正确调用 `trap_handler`。为了绕开这一行为，我们需要在用户程序的上下文中放置 `trap_handler` 的地址，从而允许我们加载 `trap_handler` 的地址从而调用。之后我们只需将 stvec 设置为 `trap_handler` 的虚拟地址即可。

另外此时虽然我们没有编写相关的支持，但是我们已经可能会在开发时收到 S 态的中断/异常了（比如页错误）。为此我们需要在内核态时和在用户态时使用不同的中断处理函数。因此我们需要准备一个内核用的中断处理函数。因此我们在 `trap.asm` 中增加一个 4 字节对齐的 `__ktraps` 函数，由它调用 Rust 的 `trap_from_kernel` 函数触发 panic。同时，在 `trap_handler` 函数的开头和结尾分别切换中断处理函数，并在首次进入用户程序时不直接进入 `__restore` 而是进入 `launch` 函数来设置中断处理函数。如此便可在内核出现内存访问错误时 panic，甚至可以在此时看到完整的调用栈信息。

接下来我们需要在上下文切换时切换 satp 的内容。由于内核栈现在在用户态的虚拟地址和内核态的虚拟地址完全不同，而我们又无法在不破坏通用寄存器的情况下切换 satp，所以我们在切换 satp 时还需要切换内核栈的地址。为此我们先在用户程序的上下文中加入内核地址空间和用户地址空间的以及 satp。然后在进入用户态时先读取并切换地址空间与栈再进行后续操作，而在回到内核态时先将上下文放置在栈上再读取切换地址空间和栈。

## 内核栈溢出保护，以及加载 ELF 格式应用

现在我们终于可以利用地址空间映射来做一些实际的工作了。为此我们用 `VMObjectPaged` 结构来表示一组分配好的物理页，它也实现了 `VMObject` trait ，这样我们便可以方便地将其映射到页表中。

接下来，我们来实现内核栈保护。为此我们给每个应用在较高的一半地址空间分配一段地址，并在中间分别隔开一页。同时，内核栈的物理内存的分配也改为使用 `VMObjectPaged` 自动进行。

最后，我们终于可以直接加载 ELF 格式的二进制文件了。不过在此之前，我们需要把 `sys_write` 从用户空间读取数据的方式改为通过 `AddressSpace` 进行查询的方式，这样之后移动用户程序的地址空间后不会出错。为此我们先在 `VMObject` trait 上加上读写操作，之后再在 `AddressSpace` 上加入读写内存空间内映射的内存的方法，之后就可以直接通过 `AddressSpace` 读写当前用户程序的内存空间了。之后我们便可以实现 ELF 格式用户程序的加载了。至于 ELF 格式的加载，首先更改编译脚本和 build.rs，让内核中直接包含ELF格式的二进制，然后更改用户程序链接脚本使得用户程序 ELF 各段开始部分是按页对齐的，之后把加载用户程序二进制的部分改为使用之前用过的 `object` 库进行解析，并将各段内容复制进 `VMObjectPaged` 并映射到用户程序的 `AddressSpace` ，最后再加上用户栈的分配与映射即可。注意此时，用户程序的入口地址和初始 sp 也需要进行改变。

现在我们可以不再为各个用户程序指定各自的地址空间了，于是便可以对所有的用户程序均采用相同的地址空间了。同时我们也不必为用户程序预留物理空间了，毕竟应用程序使用的物理地址空间现在是通过  `VMObjectPaged` 自动分配的。