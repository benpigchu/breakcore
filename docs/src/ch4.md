# 第四章：内存管理与虚拟内存

## 内核堆

我们使用 buddy_system_allocator 库进行内存管理。这个库使用了 buddy_system 算法来分配内存。把它提供的 LockedHeap 作为堆内存分配器 `#[global_allocator]` 使用，并开一个大数组作为堆空间为进去即可。同时我们也定义 `#[alloc_error_handler]` ，使得内存不够时打印信息并停机。

有了内核堆，我们就可以使用 alloc 包的内容了，这样就可以自由地使用 Box、Arc、Vec 等进行动态内存分配了。

## Bonus：更详细的报错信息

有了堆内存，我们可以开始解析二进制中含有的调试相关信息了，为此我们首先需要在我们的二进制中放置内核调试信息。第一步是提取调试信息，这一部分只需要使用`objcopy` 加上 `--only-keep-debug`就好。第二步是把调试信息加载到内存中，这里我们使用 qemu 的 loader 设备来完成，注意为了避免 qemu 解析 ELF 格式我们需要指定 `force-raw=on`。为了方便，我们把调试信息加载到 `0x80800000` 处。第三步是在内核中读取调试信息，这里我们相应使用 `object` 库解析 ELF 格式，并将相应的段喂给 `addr2line` 库里带的 `gimli` 库。最后，我们在打印 backtrace 时，使用 ra 地址信息用 `addr2line` 库查询相关信息并打印即可。

这时，我们的内核报错打印 backtrace 时就能把函数名称和文件地址与行号列号也显示出来了，应该能对之后的调试产生很大的帮助。

另外，在 Release 模式下，需要在 `.cargo` 中指定输出调试信息，否则在 Release 模式下 Rust 不会生成调试信息，也就无法打印更详细的 backtrace 了