# 第四章：内存管理与虚拟内存

## 内核堆

我们使用 buddy_system_allocator 库进行内存管理。这个库使用了 buddy_system 算法来分配内存。把它提供的 LockedHeap 作为堆内存分配器 `#[global_allocator]` 使用，并开一个大数组作为堆空间为进去即可。同时我们也定义 `#[alloc_error_handler]` ，使得内存不够时打印信息并停机。

有了内核堆，我们就可以使用 alloc 包的内容了，这样就可以自由地使用 Box、Arc、Vec 等进行动态内存分配了。

## Bonus：更详细的报错信息

有了堆内存，我们可以开始解析二进制中含有的调试相关信息了，为此我们首先需要在我们的二进制中放置内核调试信息。第一步是提取调试信息，这一部分只需要使用`objcopy` 加上 `--only-keep-debug`就好。第二步是把调试信息加载到内存中，这里我们使用 qemu 的 loader 设备来完成，注意为了避免 qemu 解析 ELF 格式我们需要指定 `force-raw=on`。为了方便，我们把调试信息加载到 `0x80800000` 处。第三步是在内核中读取调试信息，这里我们相应使用 `object` 库解析 ELF 格式，并将相应的段喂给 `addr2line` 库里带的 `gimli` 库。最后，我们在打印 backtrace 时，使用 ra 地址信息用 `addr2line` 库查询相关信息并打印即可。

这时，我们的内核报错打印 backtrace 时就能把函数名称和文件地址与行号列号也显示出来了，应该能对之后的调试产生很大的帮助。

另外，在 Release 模式下，需要在 `.cargo` 中指定输出调试信息，否则在 Release 模式下 Rust 不会生成调试信息，也就无法打印更详细的 backtrace 了

## 分配物理页

在正式分配物理页之前，我们首先建立一些辅助类型用来表示页号和地址，并编写一些工具函数方便对它们进行处理。

我们采取简单的栈式物理页管理策略进行物理页的管理。具体来说，就是保存还未进行分配的页的区间、以及一个回收的物理页表列表。分配时优先从回收的列表里取，再尝试从未分配的区间取。还回时直接加到回收的列表里即可。具体实现上我们利用回收的页的内部空间建立链表来管理回收的物理页，这样我们的物理页分配器便不依赖于内核堆。

最后为了让我们更好地管理页面的生命周期，我们用一个实现了 `Drop` 的 `Frame` 来表示物理页。这样当物理页的生命周期结束后，物理页会自动回收。

## 使用页表保护内存

首先我们需要能够操作页表结构。虽然我们使用的 `riscv` 包是有 Sv48 页表支持，但是我们要使用的是 Sv39 页表，所以我们得自己重新实现一遍。