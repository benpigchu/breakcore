# 第二章：用户态和用户程序、批处理系统

## 准备用户程序

用户程序和内核一样，都是 RV64 架构上的 no_std 程序，只是运行在用户态而已，所以我们用类似的方法就可以建立起用户程序的 Crate。但是这里略有区别的是，user 是一个库，而其中附带了一些用户程序放在 bin 文件夹里。由于这样的文件布局，我们需要在 bin 文件内使用 `extern crate` 来引用用户库。

除此之外我们还需要想办法方便内核跳转到用户程序，而这就需要我们使用链接器脚本来调整入口的位置。同时，我们还需要自行提供初始化用的 `_start` 函数。和内核中不同的是，我们的栈已经由内核准备好了，所以我们可以用 Rust 而不是汇编来编写这个函数。注意 `#[link_section = ".text.entry"]` 这个标记为我们特别设定了此函数所在的段，这样我们才能在链接器脚本中固定这个函数的位置。当然，我们还需要 `#[no_mangle]` 和 `extern "C"` 来方便内核调用它。

最后我们需要在 `_start` 中调用主函数。但是，如果我们没有在库里放一个主函数，那么就无法通过编译。于是为了使库中的主函数能够被用户程序覆盖，我们需要加入 `#[linkage = "weak"]` 来使函数重复时能被覆盖。

## 进入用户态，以及回到内核态

首先我们把用户程序打包到内核的二进制文件里去。只需要在编译用户程序之后用汇编直接把 binary 嵌入进去即可。当然，为了以后能够支持多应用程序的时候能够较为顺畅地把多个程序都嵌入进去，我们使用了 `build.rs` 在编译时生成汇编程序。

接下来我们可以开始实现用户态和内核态的切换了。在 RV64 下，我们使用 S 态和 U 态分别作为内核态和用户态。在 RV64 下，我们使用 ecall 来返回更高权限的层，用 eret 来进入（或者回到）更低权限的层。在这个过程中我们需要切换PC和栈。听起来似乎很简单，但是其实牵扯到很多内容。

首先我们需要能够切换到用户态。要切换到用户态，我们只需要设置栈寄存器，通过 sepc CSR 设置执行 sret 后跳到的地址，然后设置 sp，最后执行 sret 就好了。具体的实现上我们先把 context 塞到新的内核栈，再调用 `trap.asm` 中的 `__restore` 函数，然后它会切换到新的内核栈，然后就从栈上获取上述几步所需的信息，进入用户态了。

此时虽然还没有任何新的输出，但是用 qemu 控制台的 info registers 指令已经可以看到我们已经在用户程序里死循环了。

接下来，我们需要回到内核态。对于用户程序来说，只需要简单使用 ecall 指令就好了。但是为了让内核能够处理中断我们需要提前做点准备。首先是设置 stvec 设定中断处理函数的地址 `__alltraps`。这里我们为了方便使用 riscv 库定义的工具方法和函数来进行。注意我们设置的是 Direct 模式，这使得所有的中断都通过同一个函数来执行，而我们之后再判断中断的类型分别处理。然后我们再在 `__alltraps` 中换回内核栈再调用回 Rust 中的函数就好。最后，为了能在回到内核中只能能够使用正确的栈，我们需要在进入用户态把栈寄存器的内容存入 sscratch，防止用户修改。

## 实现系统调用

能在内核和用户空间之间切换之后，我们就可以实现系统调用了。但是要让我们再次回到用户态后用户程序能够原地重新开始运行，我们需要保存用户程序的上下文信息并在回到用户态时恢复，因为这些内容可能会被内核覆盖掉。用户程序的上下文当然包括所有的通用寄存器（x0除外，因为它是不可变的），以及会在 sret 时用到的 sstatus 以及 sepc（因为嵌套的中断会将其覆盖）。另外注意 x2 寄存器因为用作栈寄存器需要特殊处理。具体实现上，我们把内核栈开头部分的空间固定用于存放上下文，并将指向它的指针作为参数传给 `trap_handler` 。而 `trap_handler` 也会把这个指针原样返回，之后汇编代码会直接进入 `__restore` 函数，返回用户态。

接下来就是实现具体的中断处理过程了。首先我们可以在 scause 和 stval 中读到中断的原因和相关的参数（比如页错误的地址），那么就可以分类进行处理了。