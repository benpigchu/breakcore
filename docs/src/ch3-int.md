# 第三章第二部分：抢占式调度的分时多任务系统

## 处理时钟中断

首先我们需要启用从 U 态到 S 态中断。为此，我们需要在应用程序的上下文中的 sstatus 中设置 spie bit，这样等进入用户态之后我们便可以收到中断了。同时，我们也设置 sie 中的 stip 开启时钟中断。之后，我们再根据 time 寄存器获得当前时间，再根据这个时间通过 SBI 调用设置时钟，这样我们便可以在 U 态时通过时钟中断切换到 S 态了。之后只需要在时钟中断处理中中切换上下文即可。

注意此时应用程序的输出十分混乱，这是因为用户程序并不会一次输出一整行的内容，而是分开输出各个部分。将来第四章引入动态内存分配之后我们就可以先拼好一行的字符串再输出了。

## 实现 get_time 和 sleep

我们只需要把 time 寄存器进行一些处理（除以一个每毫秒的 tick 数）再传回用户空间即可。这时我们便可以通过轮询实现 sleep 了。

## 实现 Stride 调度器

不同的应用程序有不同的优先级，优先级更高的应用程序应该占用更多的 CPU 时间。为此我们需要更高级的调度方式。首先，我们把调度器从任务管理的 `TaskManager` 分拆出来，用 `Scheduler` trait 表示。每个调度器都有对应的数据可以放在 `Task` 结构里，用于方便调度器实现。而 `Scheduler` trait 上面有两个方法，一个 `proc_tick` 方法用于在用户程序运行完一个时间片时更新每个 `Task` 内的和其本身的数据，而另一个 `pick_next` 方法则用于选择接下来需要运行的用户程序。

对于 Stride 调度算法，我们只需要在每个 `Task` 内存放该进程前进的距离，然后在 `proc_tick` 中增长应用程序的距离，然后在 `pick_next` 中选择目前距离最短的进程即可。应用程序一次前进的距离由优先级的倒数决定。由于应用程序一次前进的距离不会很大，而我们的算法优先让落后的应用程序前进，所以所有应用程序的距离之差不会大于一步最多前进的距离。那么，我们可以安心的循环利用 usize 的范围了。另外在实际的实现中，为了绕开 Rust 的借用检查，我们需要使用 `Cell` 来让不可变结构的内部可变。

最后只需要实现设置优先级的系统调用就可以完成整个调度系统了。可以看到， Stride 调度算法中每个用户程序的运行时间大致正比于优先级。