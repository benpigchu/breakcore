# 第三章第一部分：非抢占式调度的分时多任务系统

## 为不同的应用程序指定不同的内存空间

由于我们需要同时执行不同的应用程序，所以我们需要把他们放在不同的地址空间，于是便需要为他们指定不同的基地址。为此我们需要大幅修改用户程序的编译过程。首先，我们需要在用户程序包当中加入 `build.rs` 在编译时生成链接器脚本。其次我们需要改写编译脚本，使之分别编译各个用户程序，并分别设置基地址。为了验证这些修改，我们把内核中用户程序加载的地址也进行调整，由应用程序的编号决定具体的内存地址。

同样的，栈空间也需要分离开来。这一点我们只需要预留好应用数量那么多的栈空间，并稍作修改相关的部分就好。

## 做好其他准备

由于将来应用运行管理的逻辑会加入很多内容（比如本次的 yield ），应用加载的逻辑也会加入很多内容（比如第四章即将加入的加载 ELF 格式应用），我们需要将两部分切分开来。应用加载的部分包括复制应用程序二进制以及初始化栈，应用运行的部分则负责管理应用运行的状态。

然后，让我们实现 yield 的 syscall 接口，留一个空的实现，这样虽然没有实现功能，但是用户程序还是会正常运行。最后让我们引入新的测试用户程序进行测试。我们就做好了一切准备。

## 在用户程序之间切换

首先我们需要维护各个应用程序各自的状态。目前我们用到的状态包括：尚未启动、正在运行、可以继续运行、以及已经结束。在正式实现yield之前，我们并没有第三个状态。


