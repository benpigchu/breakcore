# 第三章第一部分：非抢占式调度的分时多任务系统

## 为不同的应用程序指定不同的内存空间

由于我们需要同时执行不同的应用程序，所以我们需要把他们放在不同的地址空间，于是便需要为他们指定不同的基地址。为此我们需要大幅修改用户程序的编译过程。首先，我们需要在用户程序包当中加入 `build.rs` 在编译时生成链接器脚本。其次我们需要改写编译脚本，使之分别编译各个用户程序，并分别设置基地址。为了验证这些修改，我们把内核中用户程序加载的地址也进行调整，由应用程序的编号决定具体的内存地址。

同样的，栈空间也需要分离开来。这一点我们只需要预留好应用数量那么多的栈空间，并稍作修改相关的部分就好。

## 做好其他准备

由于将来应用运行管理的逻辑会加入很多内容（比如本次的 yield ），应用加载的逻辑也会加入很多内容（比如第四章即将加入的加载 ELF 格式应用），我们需要将两部分切分开来。应用加载的部分包括复制应用程序二进制以及初始化栈，应用运行的部分则负责管理应用运行的状态。

然后，让我们实现 yield 的 syscall 接口，留一个空的实现，这样虽然没有实现功能，但是用户程序还是会正常运行。最后让我们引入新的测试用户程序进行测试。我们就做好了一切准备。

## 在用户程序之间切换

首先我们需要维护各个应用程序各自的状态。目前我们用到的状态包括：尚未启动、正在运行、可以继续运行、以及已经结束。在正式实现yield之前，我们并没有第三个状态。我们需要在应用退出、切换、启动时更新状态，并在切换时根据状态决定切换到什么应用程序。

那么接下来就是实现应用间切换了。应用间切换其实本质上是在内核栈之间切换。当然我们需要保存内核栈的上下文，这样切换走之后可以切换回去。内核栈的上下文显然包括 sp ，返回地址 ra，同时还要包括需要由被调用方保存的各个寄存器，而这包括 s0-s11。对于具体的汇编实现 `__switch` ，我们把上下文放在栈上，并保存指向上下文的指针，这样切换时只需要把上下文保存，把 sp 写入传入的指针，再从传入的指针恢复 sp 并恢复上下文即可。

同时，对于进入新应用的情况，我们需要改用 `__switch` 来保证我们能够回到当前应用，这就需要我们初始化内核栈的时候把任务上下文也一并放进去。注意此时我们不必像第二章一样，从 `__restore` 的参数读取栈地址了。

最后，我们把 `yield` 系统调用也接入切换上下文的代码就好了。