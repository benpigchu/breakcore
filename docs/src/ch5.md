# 第五章：进程管理

## 重构任务管理

首先，为了之后用户程序可以按照用户程序的名称来启动其它用户程序，我们需要在装载应用程序时同时装载它的名称。为此，我们更改 `build.rs` 使其在生成 `embed_app.asm` 时在其中包含应用的名称信息，同时对 `AppManager` 进行重构，让它用 `BTreeMap` 来存储应用名称和应用具体数据位置的对应关系。同时，我们记录第一个应用的名称作为初始应用。

其次，我们需要对 `task` 模块进行较大的重构。一方面我们要把 `Task` 中可变的部分放入 `Mutex` 中，而 `TaskManager` 存放的 `Task` 数组也改为 `Vec<Arc<Task>>` 。另一方面我们要把 `Task` 初始化的工作放入它的构造函数中，并删除任务未初始化的状态。同时，我们需要把一些 `TaskManager` 上的方法移动到 `Task` 上，同时 `TaskManager` 以 `Arc<Task>` 的形式返回当前 `Task` 。

然后，为了方便之后实现 `fork` 和 `exec`，我们需要把加载 ELF 和用户栈的部分与初始化用户程序上下文和内核栈的部分分离开。首先对于每个 `Task` ，都要分配对应的内核栈，为此我们用 `PidHandle` 管理 `Task` 的编号，并以此决定对应的内核栈在内核地址空间内的地址位置。在 `PidHandle` 分配时我们分配内核栈的  `VMObjectPaged` 并进行映射，而在 `PidHandle` 的 `Drop` 的实现中我们取消映射。其次，我们把用户地址空间初始化的工作移动到 `AddressSpace` 上，由它建立跳板页的映射并分配与映射用户上下文所在的页。然后，剩下的部分就是加载 ELF 了，它只需要解析 ELF 、分配对应的内存、在已有的 `AddressSpace` 映射对应的页，初始化用户栈，之后返回应用程序的入口和用户栈地址即可。完成这样的拆分后，我们便可以把初始化任务和加载程序的过程分开了。

最后，我们要对 `TaskManager` 管理 `Task` 的方式进行修改。首先我们当前的任务应当用 `Arc<Task>` 而非序号来表示当前任务，其次，我们让 `TaskManager` 中只存放接下来可以运行的 `Task` ，在任务切换时把当前任务（如果可以继续运行）移进列表，把接下来的任务移出列表，这样可以尽早销毁任务，回收资源。不过要注意的是，我们应当在上下文切换后再销毁 `Task`，因为切换前我们还要使用任务的内核栈，为此我们在切换前把之前的任务移入 `TaskManager` 的 `last` 字段暂存，切换后再进行销毁。同时，启动时我们也改为仅启动初始应用而非之前的加载所用应用。

## 实现 fork 和 exec

要实现 fork，我们需要创建 `Task` ，并从原来的 `Task` 复制地址空间和上下文。

首先我们在 `VMObject` trait 上新增一个 `create_clone` 方法，用于复制一块内存空间。对于 `VMObjectPhysical` ，它不应当可复制，所以直接返回 `None`，而对于 `VMObjectPaged` 则会分配新的内存空间，并复制内容，最后创建一个新的 `VMObjectPaged` 。然后我们在 `AddressSpace` 上新增一个 `fork_from` 方法，用于从另一个 `AddressSpace` 将用户程序可以接触到的内存空间复制过来。它会调用 `VMObject` trait 上的 `create_clone` 方法复制内存内容，并建立对应的映射。

之后我们在 `Task` 上新增一个 `new_fork` 函数，它会先创建一个基本的 `Task`， 然后调用它的 `AddressSpace` 上的 `fork_from` 复制地址空间，然后再将上下文中通用寄存器、 pc 、sstatus 的内容复制过去，并将存放 syscall 返回值的寄存器改为 0。最后在系统调用时用 `new_fork` 新建 `Task` ，并将其加入接下来可以运行的 `Task` 列表即可。

要实现 exec，我们首先在 `AddressSpace` 上新增一个 `clean_user` 方法，用于清除原有的用户空间映射。同时，我们使加载 ELF 的方法在确认 ELF 存在且格式正确时调用 `clean_user` 方法，而在未能确认 ELF 格式时直接返回。之后我们在在 `Task` 上新增一个 `exec` 函数，它会先尝试重新加载 ELF 文件，如果成功则对应重置应用程序上下文。最后，由于 exec 的接口需要使用 0 结尾的字符串的指针，我们在 `AddressSpace` 上新增 `read_cstr` 方法读取 0 结尾的字符串。最后把这些组合在一起，读取字符串并调用 `Task` 上的 `exec` 函数，我们便实现了 exec。